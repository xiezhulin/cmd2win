#!/usr/bin/env python2
# coding: utf-8
#
# Copyright (c) Guangdong vivo software technology CO.,LTD. Unpublished
#
# Guangdong vivo software technology CO.,LTD.
# Proprietary & Confidential
#
# This source code and the algorithms implemented therein constitute
# confidential information and may comprise trade secrets of vivo
# or its associates, and any use thereof is subject to the terms and
# conditions of the Non-Disclosure Agreement pursuant to which this
# source code was originally received.
#
# Description:
#     do smb operation, you need config smb_monitor.py on windows and start it
#
# Author:
#       Ronny<xiezhulin@vivo.com>
#
# Version infomation:
#     Version  Date            Description
#     v1.0     Mar 08, 2016    first version
#     v1.1     Jan 03, 2017    improve performance and fix bug that can't open directory
#     v1.2     Apr 18, 2018    support open parent directory and custom command
#     v1.3     July 26, 2018   support clip command
#

import os
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import time
import optparse
import socket
import struct

class SmbCmd():
    usage="""dosmb [Optinos] [Args]
Args:
    cmp <src> <dst>
        cmp two files or directories

    open [file/directory] [...]
        open files or directories, defaults to the current directory

    open_parent_dir [file/directory] [...]
        open the parent directory of given files or directories, defaults to the current directory

    custom <"windows command"> [file/directory] [...]
        run windows command, file and directory can be converted to smb path(s), defauls to the
        current directory if file/directory no given
        .e.g:
            dosmb --host 172.25.105.45 custom "adb install -r" ./build/testdemo.apk

    clip <file/directory/content>
        copy content or a smb path of the given file/directory to window's clipboard, defaults to the current directory"""

    home = os.environ.get('HOME')
    user = os.environ.get('USER')

    verbose = False
    default_host = '192.168.8.8'
    default_port = 8090
    try:
        # such as c:\\
        prefix = os.environ['SMB_MAP_DRIVE']
    except KeyError:
        prefix = ''

    editor = ''
    try:
        # such as notpad++,gvim
        editor = os.environ['SMB_TXT_EDITOR']
    except KeyError:
        pass
    finally:
        if not editor:
            editor = 'notepad'

    editor_support_multi_files = False
    try:
        # such as notpad++,gvim
        if os.environ['SMB_TXT_EDITOR_SUPPORT_MULTI_FILES'] == 'True' or \
            os.environ['SMB_TXT_EDITOR_SUPPORT_MULTI_FILES'] == 'true':
            editor_support_multi_files = True
    except KeyError:
        pass

    comparer = ''
    try:
        # such as Bcompare
        comparer = os.environ['SMB_COMPARER']
    except KeyError:
        pass
    finally:
        if not comparer:
            comparer = 'fc'

    def __init__(self, *args):
        cmd = self.parse_args()
        if not cmd:
            return

        self.s = socket.socket()
        self.s.connect((self.host, self.port))
        self.ipaddr = self.s.getsockname()[0]
        if not self.prefix:
            self.prefix = r'\\' + self.ipaddr + '\\' + self.user

        while self.prefix.endswith('\\'):
            self.prefix = self.prefix[:-1]

        self.run(cmd)

    def to_absolute_and_valid(self, path):
        absolute = os.path.realpath(path)
        if absolute.find(self.home) == -1:
            print("Your given path must be under HOME -> %s" % (self.home, ))
            sys.exit(0)
        return absolute

    def path2smb(self, path):
        smb_path = path.replace(self.home, '')
        smb_path = smb_path.replace('/', '\\')
        return self.prefix + smb_path

    def parse_args(self):
        p = optparse.OptionParser(usage=self.usage, add_help_option=True)
        p.add_option('--host',
                        dest='host',
                        help='server host, defaults to %s' % self.default_host,
                        metavar='HOST',
                        default=self.default_host)
        p.add_option('-p',
                        '--port',
                        dest='port',
                        help='server port, defaults to %d' % self.default_port,
                        metavar='PORT',
                        default=self.default_port)
        p.add_option('-v', '--verbose',
                        dest='verbose',
                        action='store_true',
                        help='verbosely list processed')

        opt, remainder = p.parse_args()
        if opt.verbose:
            self.verbose = True
        if opt.host:
            self.host = opt.host
        if opt.port:
            self.port = int(opt.port)

        if len(remainder) < 1:
            print("No args given!\nRun 'dosmb -h' to get help")

        return remainder

    def cmp(self, args):
        if len(args) != 2:
            print("cmp need two args")
            return ''

        for p in args:
            if not os.path.exists(p):
                print("%s: No such file or directory" % (p,))
                return ''

        src = self.to_absolute_and_valid(args[0])
        dst = self.to_absolute_and_valid(args[1])

        buf = "%s %s %s" % (self.comparer, self.path2smb(src), self.path2smb(dst))
        return buf

    def open(self, args, parent=False):
        if len(args) == 0:
            args = [os.getcwd(), ]
            if self.verbose:
                print("Use current working directory as defaut")

        cmd = []
        dirlist = []
        filelist = []

        for p in args:
            if parent:
                p = os.path.dirname(self.to_absolute_and_valid(p))

            if not os.path.exists(p):
                print("%s: No such file or directory" % (p,))
                return ''

            p_real = self.to_absolute_and_valid(p)
            p_smb = self.path2smb(p_real)
            if os.path.isdir(p):
                dirlist.append(p_smb)
            elif os.path.isfile(p):
                filelist.append(p_smb)
            else:
                print("%s: unknown type" % (p,))
                return ''

        for d in dirlist:
            cmd.append(u'start %s' % d)


        if filelist:
            if self.editor_support_multi_files:
                cmd.append(u'%s %s' % (self.editor, ' '.join(filelist)))
            else:
                for d in filelist:
                    cmd.append(u'%s %s' % (self.editor, p_smb))

        return ' | '.join(cmd)


    """
    @params args[0]:
        windows command, double quotation marks are used as references for multi-words,
        such as "adb install" /path/to/test.apk
    @params args[1..n]:
        linux path, use current directory as default when args[1..n] no given
    """
    def custom(self, args):
        if len(args) < 1:
            print("Invalid paramters, custom need one parameter at least")
            return ''

        cmd = []
        cmd.append(args[0])

        args = args[1:]
        if len(args) == 0:
            args = [os.getcwd(), ]
            if self.verbose:
                print("Use current working directory as defaut")

        for p in args:
            if not os.path.exists(p):
                print("%s: No such file or directory" % (p,))
                return ''
            else:
                p_real = self.to_absolute_and_valid(p)
                p_smb = self.path2smb(p_real)
                cmd.append(p_smb)

        return ' '.join(cmd)

    def clip(self, args):
        if len(args) == 0:
            args = [os.getcwd(), ]
            if self.verbose:
                print("Use current working directory as defaut")
        elif len(args) != 1:
            print("Only one parameter, please retry")
            return

        p = args[0]
        if not os.path.exists(p):
            print("%s: No such file or directory" % (p,))

        p_real = self.to_absolute_and_valid(p)
        p_smb = self.path2smb(p_real)
        print("clip -> %s" % (p_smb, ))
        # can't contain a space before '|'
        return "echo x|set/p =" + p_smb + "| clip"

    def run(self, cmd):
        name = cmd[0]
        args = cmd[1:]
        if name == 'cmp':
            smb_cmd = self.cmp(args)
        elif name == 'open':
            smb_cmd = self.open(args)
        elif name == 'open_parent_dir':
            smb_cmd = self.open(args, parent=True)
        elif name == 'custom':
            smb_cmd = self.custom(args)
        elif name == 'clip':
            smb_cmd = self.clip(args)
        else:
            print("Unsupport cmd: %s" % (name, ))
            return ''

        if smb_cmd:
            self.s.send(smb_cmd)
            if self.verbose:
                print("Send: [%s]" % (smb_cmd,))

        self.s.close()

if __name__ == '__main__':
    SmbCmd(sys.argv[1:])

