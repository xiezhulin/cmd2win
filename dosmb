#!/usr/bin/env python2
# coding: utf-8
#
# Copyright (c) Guangdong vivo software technology CO.,LTD. Unpublished
#
# Guangdong vivo software technology CO.,LTD.
# Proprietary & Confidential
#
# This source code and the algorithms implemented therein constitute
# confidential information and may comprise trade secrets of vivo
# or its associates, and any use thereof is subject to the terms and
# conditions of the Non-Disclosure Agreement pursuant to which this
# source code was originally received.
#
# Description:
#     do smb operation, you need config smb_monitor.py on windows and start it
#
# Author:
#       Ronny<xiezhulin@vivo.com>
#
# Version infomation:
#     Version  Date            Description
#     v1.0     Mar 08, 2016    first version
#     v1.1     Jan 03, 2017    improve performance and fix bug that can't open directory
#     v1.2     Apr 18, 2018    support open parent directory and custom command
#     v1.3     July 26, 2018   support clip command
#     v1.4     Sep 19, 2018    support multi-config smab share directory, unsupport enviornment 'SMB_MAP_DRIVE', always use windows ip as prefix
#

import os
import sys
reload(sys)
sys.setdefaultencoding('utf-8')
import optparse
import socket

class SmbCmd():
    USAGE = """dosmb [Optinos] [Args]
Args:
    cmp <src> <dst>
        cmp two files or directories

    open [file/directory] [...]
        open files or directories, defaults to the current directory

    open_parent_dir [file/directory] [...]
        open the parent directory of given files or directories, defaults to the current directory

    custom <"windows command"> [file/directory] [...]
        run windows command, double quotation marks are used as references for multi-words; file/directory will be
        kept its native format if it starts with a colon, or convert to samba format; file/directory no defaults

        .e.g:
            dosmb --host 192.168.1.1 custom "adb install -r" ./build/testdemo.apk
            dosmb --host 192.168.1.1 custom "adb push" ./app/build/outputs/apk/debug/app-debug.apk :/system/app/TestDemo
            dosmb --host 192.168.1.1 custom "adb root & adb remount"
            dosmb --host 192.168.1.1 custom "adb remount"
            dosmb --host 192.168.1.1 custom "adb shell mkdir -p" :/system/app/TestDemo
            dosmb --host 192.168.1.1 custom "adb shell rm -rf" :/system/app/TestDemo

    clip <file/directory/content>
        copy content or a smb path of the given file/directory to window's clipboard, defaults to the current directory"""

    env = os.environ
    HOME = os.path.realpath(env.get('HOME'))
    USER = env.get('USER')

    # config default windows host and port
    DEFAULT_HOST = '192.168.1.1'
    DEFAULT_PORT = 8090

    # parse unix environment variables
    COMPARER = 'SMB_COMPARER'
    TXT_EDITOR = 'SMB_TXT_EDITOR'
    TXT_EDITOR_SUPPORT_MULTI_FILES = 'SMB_TXT_EDITOR_SUPPORT_MULTI_FILES'

    comparer = env[COMPARER] if COMPARER in env else 'fc'
    editor = env[TXT_EDITOR] if TXT_EDITOR in env else 'notepad'

    if TXT_EDITOR_SUPPORT_MULTI_FILES in env:
        if env[TXT_EDITOR_SUPPORT_MULTI_FILES] == 'True' or env[TXT_EDITOR_SUPPORT_MULTI_FILES] == 'true':
            editor_support_multi_files = True
    else:
        editor_support_multi_files = False

    # default disable
    verbose = False

    def __init__(self, *args):
        cmd = self.parse_args()
        if not cmd:
            return

        self.shares = {}
        self.s = socket.socket()
        self.s.connect((self.host, self.port))
        self.ipaddr = self.s.getsockname()[0]
        self.run(cmd)

    def get_user_smb_conf(self):
        # get valid line
        lines = []
        with open('/etc/samba/smb.conf') as f:
            for line in f:
                line = line.strip()
                if line.startswith(';') or line.startswith('#') or line == '':
                    continue
                lines.append(line)

        # parse to map
        sections = {}
        section = None
        for line in lines:
            if line.startswith("[") and line.endswith(']'):
                section = line.strip('[').strip(']')
                sections.setdefault(section, {})
            else:
                pair = line.split("=")
                if not section or len(pair) != 2:
                    raise Exception("smb.conf: invalid format")

                key =  pair[0].strip()
                value = pair[1].strip()
                sections[section][key] = value

        # filter
        ignore_sections = ("global", "printers", "print$")
        for k in ignore_sections:
            if k in sections:
                sections.pop(k)

        return sections

    """
    @return: a dictionary with share name as key, linux path as value
    """
    def get_smb_share_map(self):
        #TODO: check permisson
        if not self.shares:
            key_path = "path"
            sections = self.get_user_smb_conf()
            for section, content in sections.iteritems():
                if key_path in content:
                    value_path = os.path.realpath(content[key_path].strip())
                    if value_path.find(self.HOME) != -1:
                        self.shares[section] = value_path
                    elif self.verbose:
                        print("[%s] %s not found my home(%s)" % (section, value_path, self.HOME))

        return self.shares

    def real_valid_path(self, path):
        absolute = os.path.realpath(path)
        if absolute.find(self.HOME) == -1:
            print("Your given path must be under  -> %s" % (self.HOME, ))
            sys.exit(0)
        return absolute

    def realpath2smb(self, path):
        found = 0
        for sharename, sharepath in self.get_smb_share_map().iteritems():
            if path.find(sharepath) != -1:
                smb_path = path.replace(sharepath, sharename).replace('/', '\\')
                found = 1
                break
        if found == 0:
            print("No found corresponding smb config")
            sys.exit(2)

        return r'\\' + self.ipaddr + '\\' + smb_path

    def parse_args(self):
        p = optparse.OptionParser(usage=self.USAGE, add_help_option=True)
        p.add_option('--host',
                        dest='host',
                        help='server host, defaults to %s' % self.DEFAULT_HOST,
                        metavar='HOST',
                        default=self.DEFAULT_HOST)
        p.add_option('-p', '--port',
                        dest='port',
                        help='server port, defaults to %d' % self.DEFAULT_PORT,
                        metavar='PORT',
                        default=self.DEFAULT_PORT)
        p.add_option('-v', '--verbose',
                        dest='verbose',
                        action='store_true',
                        help='verbosely list processed')

        opt, remainder = p.parse_args()
        if opt.verbose:
            self.verbose = True
        if opt.host:
            self.host = opt.host
        else:
            print("You should config host ipaddress by --host, details to run 'domsb --help'")

        if opt.port:
            self.port = int(opt.port)

        if len(remainder) < 1:
            print("No args given!\nRun 'dosmb -h' to get help")

        return remainder

    def cmp(self, args):
        if len(args) != 2:
            print("cmp need two args")
            return ''

        for p in args:
            if not os.path.exists(p):
                print("%s: No such file or directory" % (p, ))
                return ''

        src = self.real_valid_path(args[0])
        dst = self.real_valid_path(args[1])

        buf = "%s %s %s" % (self.comparer, self.realpath2smb(src), self.realpath2smb(dst))
        return buf

    def open(self, args, parent=False):
        if len(args) == 0:
            args = [os.getcwd(), ]
            if self.verbose:
                print("Use current working directory as defaut")

        cmd = []
        dirlist = []
        filelist = []

        for p in args:
            if parent:
                p = os.path.dirname(self.real_valid_path(p))

            if not os.path.exists(p):
                print("%s: No such file or directory" % (p, ))
                return ''

            p_real = self.real_valid_path(p)
            p_smb = self.realpath2smb(p_real)
            if os.path.isdir(p):
                dirlist.append(p_smb)
            elif os.path.isfile(p):
                filelist.append(p_smb)
            else:
                print("%s: unknown type" % (p, ))
                return ''

        for d in dirlist:
            cmd.append(u'start %s' % d)


        if filelist:
            if self.editor_support_multi_files:
                cmd.append(u'%s %s' % (self.editor, ' '.join(filelist)))
            else:
                for d in filelist:
                    cmd.append(u'%s %s' % (self.editor, p_smb))

        return ' | '.join(cmd)


    """
    @params args[0]:
        windows command, double quotation marks are used as references for multi-words
    @params args[1..n]:
        keep its native format if the path starts with a colon, or convert to samba format
    """
    def custom(self, args):
        if len(args) < 1:
            print("Invalid paramters, custom need one parameter at least")
            return ''

        cmd = []
        cmd.append(args[0])

        args = args[1:]
        for p in args:
            if p.startswith(':'):
                p = p[1:]
                if self.verbose:
                    print("Skip origin path:[%s]" % (p, ))
                cmd.append(p)
            elif not os.path.exists(p):
                print("%s: No such file or directory" % (p, ))
                return ''
            else:
                p_real = self.real_valid_path(p)
                p_smb = self.realpath2smb(p_real)
                cmd.append(p_smb)

        return ' '.join(cmd)

    def clip(self, args):
        if len(args) == 0:
            args = [os.getcwd(), ]
            if self.verbose:
                print("Use current working directory as defaut")
        elif len(args) != 1:
            print("Only one parameter, please retry")
            return

        p = args[0]
        if not os.path.exists(p):
            print("%s: No such file or directory" % (p, ))

        p_real = self.real_valid_path(p)
        p_smb = self.realpath2smb(p_real)
        print("clip -> %s" % (p_smb, ))
        # can't contain a space before '|'
        return "echo x|set/p =" + p_smb + "| clip"

    def run(self, cmd):
        name = cmd[0]
        args = cmd[1:]
        if name == 'cmp':
            smb_cmd = self.cmp(args)
        elif name == 'open':
            smb_cmd = self.open(args)
        elif name == 'open_parent_dir':
            smb_cmd = self.open(args, parent=True)
        elif name == 'custom':
            smb_cmd = self.custom(args)
        elif name == 'clip':
            smb_cmd = self.clip(args)
        else:
            print("Unsupport cmd: %s" % (name, ))
            return ''

        if smb_cmd:
            self.s.send(smb_cmd)
            if self.verbose:
                print("Send: [%s]" % (smb_cmd, ))

        self.s.close()

if __name__ == '__main__':
    SmbCmd(sys.argv[1:])

